package main

import (
	"errors"
	"flag"
	"log/slog"
	"net/http"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	echoSwagger "github.com/swaggo/echo-swagger"
	_ "github.com/zeozeozeo/clickpack-db/hiatus/docs" // docs is generated by Swag CLI

	"github.com/zeozeozeo/clickpack-db/hiatus/db"
)

// @title Hiatus Download Tracker API
// @version 1.0
// @description API for tracking clickpack downloads
// @host localhost:8080
// @BasePath /

func DynamicCORS(next echo.HandlerFunc) echo.HandlerFunc {
	return func(ctx echo.Context) error {
		req := ctx.Request()
		dynamicCORSConfig := middleware.CORSConfig{
			AllowOrigins: []string{req.Header.Get("Origin")},
			AllowHeaders: []string{"Accept", "Cache-Control", "Content-Type", "X-Requested-With"},
		}
		CORSMiddleware := middleware.CORSWithConfig(dynamicCORSConfig)
		CORSHandler := CORSMiddleware(next)
		return CORSHandler(ctx)
	}
}

func main() {
	dbPath := flag.String("db", "hiatus.db", "path to database file")
	flag.Parse()
	if err := db.InitDB(*dbPath); err != nil {
		slog.Error("failed to initialize database", "error", err)
		panic(err)
	}

	// Echo instance
	e := echo.New()

	// Middleware
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())
	e.Use(DynamicCORS)

	// Rate limiter (5 requests per second per IP)
	rateLimiterConfig := middleware.RateLimiterConfig{
		Skipper: middleware.DefaultSkipper,
		Store: middleware.NewRateLimiterMemoryStoreWithConfig(
			middleware.RateLimiterMemoryStoreConfig{
				Rate:      5,
				Burst:     10,
				ExpiresIn: time.Minute,
			},
		),
		IdentifierExtractor: func(c echo.Context) (string, error) {
			return c.RealIP(), nil
		},
		ErrorHandler: func(c echo.Context, err error) error {
			return c.JSON(http.StatusTooManyRequests, map[string]string{
				"error": "too many requests",
			})
		},
		DenyHandler: func(c echo.Context, identifier string, err error) error {
			return c.JSON(http.StatusTooManyRequests, map[string]string{
				"error": "too many requests",
			})
		},
	}

	// Routes
	e.GET("/", rootHandler)
	e.POST("/inc/:name", incrementDownloadHandler, middleware.RateLimiterWithConfig(rateLimiterConfig))
	e.GET("/downloads/all", getAllDownloadsHandler)
	e.GET("/downloads/:name", getClickpackDownloadsHandler)
	e.GET("/downloads/all/since/:date", getAllDownloadsSinceHandler)
	e.GET("/downloads/:name/since/:date", getClickpackDownloadsSinceHandler)

	// Swagger UI route
	e.GET("/swagger/*", echoSwagger.WrapHandler)

	// Start server
	slog.Info("starting server on :8080")
	if err := e.Start(":8080"); err != nil && !errors.Is(err, http.ErrServerClosed) {
		slog.Error("failed to start server", "error", err)
	}
}

// rootHandler
// @Summary Show API status
// @Description Get API status
// @Tags general
// @Produce plain
// @Success 200 {string} string "hiatus is running"
// @Router / [get]
func rootHandler(c echo.Context) error {
	return c.String(http.StatusOK, "hiatus is running")
}

// incrementDownloadHandler handles POST /inc/:name
// @Summary Increment download count
// @Description Increment download count for a clickpack
// @Tags downloads
// @Accept json
// @Produce json
// @Param name path string true "Clickpack name"
// @Success 201 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 429 {object} map[string]string "Too Many Requests"
// @Failure 500 {object} map[string]string
// @Router /inc/{name} [post]
func incrementDownloadHandler(c echo.Context) error {
	name := c.Param("name")
	if name == "" {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "clickpack name is required"})
	}

	ip := c.RealIP()
	err := db.IncrementDownload(name, ip)
	if err != nil {
		if errors.Is(err, db.ErrClickpackNotInIndex) {
			return c.JSON(http.StatusNotFound, map[string]string{"error": err.Error()})
		}
		slog.Error("error incrementing download", "name", name, "error", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": "failed to record download"})
	}

	return c.JSON(http.StatusCreated, map[string]string{"message": "download recorded", "clickpack": name})
}

// getAllDownloadsHandler handles GET /downloads/all
// @Summary Get all downloads
// @Description Get download counts for all clickpacks
// @Tags downloads
// @Produce json
// @Success 200 {object} map[string]int
// @Failure 500 {object} map[string]string
// @Router /downloads/all [get]
func getAllDownloadsHandler(c echo.Context) error {
	downloads, err := db.GetAllDownloads()
	if err != nil {
		slog.Error("error getting all downloads", "error", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}
	return c.JSON(http.StatusOK, downloads)
}

// getClickpackDownloadsHandler handles GET /downloads/:name
// @Summary Get clickpack downloads
// @Description Get download count for a specific clickpack
// @Tags downloads
// @Produce json
// @Param name path string true "Clickpack name"
// @Success 200 {object} map[string]int
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /downloads/{name} [get]
func getClickpackDownloadsHandler(c echo.Context) error {
	name := c.Param("name")
	if name == "" {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "clickpack name is required"})
	}

	count, err := db.GetClickpackDownloads(name)
	if err != nil {
		slog.Error("error getting clickpack downloads", "name", name, "error", err)
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}
	return c.JSON(http.StatusOK, map[string]int{name: count})
}

// getClickpackDownloadsSinceHandler handles GET /downloads/:name/since/:date
// @Summary Get clickpack downloads since date
// @Description Get download count for specific clickpack since date (YYYY-MM-DD format)
// @Tags downloads
// @Produce json
// @Param name path string true "Clickpack name"
// @Param date path string true "Date in YYYY-MM-DD format"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /downloads/{name}/since/{date} [get]
func getClickpackDownloadsSinceHandler(c echo.Context) error {
	name := c.Param("name")
	dateStr := c.Param("date")

	if _, err := time.Parse(time.DateOnly, dateStr); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "invalid date format, use YYYY-MM-DD"})
	}

	count, err := db.GetClickpackDownloadsSince(name, dateStr)
	if err != nil {
		slog.Error("error getting clickpack downloads since date",
			"name", name, "date", dateStr, "error", err)
		return c.JSON(http.StatusInternalServerError,
			map[string]string{"error": "failed to retrieve clickpack downloads for the given date range"})
	}
	return c.JSON(http.StatusOK, map[string]any{
		"clickpack":       name,
		"downloads_since": dateStr,
		"count":           count,
	})
}

// getAllDownloadsSinceHandler handles GET /downloads/all/since/:date
// @Summary Get all downloads since date
// @Description Get download counts for all clickpacks since date (YYYY-MM-DD format)
// @Tags downloads
// @Produce json
// @Param date path string true "Date in YYYY-MM-DD format"
// @Success 200 {object} map[string]int
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /downloads/all/since/{date} [get]
func getAllDownloadsSinceHandler(c echo.Context) error {
	dateStr := c.Param("date")

	if _, err := time.Parse(time.DateOnly, dateStr); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "invalid date format, use YYYY-MM-DD"})
	}

	downloads, err := db.GetAllDownloadsSince(dateStr)
	if err != nil {
		slog.Error("error getting all downloads since date", "date", dateStr, "error", err)
		return c.JSON(http.StatusInternalServerError,
			map[string]string{"error": "failed to retrieve downloads for the given date range"})
	}
	return c.JSON(http.StatusOK, downloads)
}
